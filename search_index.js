var documenterSearchIndex = {"docs":
[{"location":"MassBalanceOpt/#MassBalanceOpt.jl","page":"API","title":"MassBalanceOpt.jl","text":"","category":"section"},{"location":"MassBalanceOpt/","page":"API","title":"API","text":"A package for formulating mass balance models of chemical processes and solving them with JuMP.","category":"page"},{"location":"MassBalanceOpt/#Flowsheets,-Streams,-and-Blocks","page":"API","title":"Flowsheets, Streams, and Blocks","text":"","category":"section"},{"location":"MassBalanceOpt/#MassBalanceOpt.AbstractBlock","page":"API","title":"MassBalanceOpt.AbstractBlock","text":"AbstractBlock\n\nAbstract supertype for all blocks (Mixer, Splitter, etc.)\n\nSee also Mixer, Splitter, Separator, YieldReactor,     MultiYieldReactor, StoicReactor, @Block_fields,     @Block_init, @Block_finish\n\n\n\n\n\n","category":"type"},{"location":"MassBalanceOpt/#MassBalanceOpt.Flowsheet","page":"API","title":"MassBalanceOpt.Flowsheet","text":"Flowsheet(name::Symbol=:index, parent=nothing)\n\nCreate a flowsheet. If name is omitted it defaults to :index. If specified, parent must be another Flowsheet; The new flowsheet will be a child of the parent flowsheet. If parent is omitted, the flowsheet has no parent.\n\nA Flowsheet serves as a container for streams, blocks (subtypes of AbstractBlock), and other flowsheets. The names of a flowsheet's ancestors are embedded in the variable and equation names of the blocks and streams contained in the flowsheet. For example, if a flowsheet named :unit1 is a child of the index flowsheet (a flowsheet created with no parent), the variable and equation names in that flowsheet will start with unit1_. If the :unit1 flowsheet has a child named reactors the names will start with unit1_reactors_.  Variables and equations in a flowsheet with no parent have no prefix.\n\nExamples\n\nCreate a :index flowsheet with no parent:\n\njulia> fs = Flowsheet()\nFlowsheet(\n   name=index   )\n\nAdd a Stream to the :index flowsheet:\n\njulia> in1 = Stream(:in1, fs, @components(h2,ch4))\nStream(in1, fs=index, basis=FRAC, components=[h2, ch4])\n\njulia> fs\nFlowsheet(\n   name=index,\n   streams=[in1]   )\n\nCreate a flowsheet named :unit1 whose parent is :index:\n\njulia> fs_1 = Flowsheet(:unit1, fs)\nFlowsheet(\n   name=unit1,\n   parent=index   )\n\njulia> fs\nFlowsheet(\n   name=index,\n   children=[unit1],\n   streams=[in1]   )\n\nSee also Stream, AbstractBlock\n\n\n\n\n\n","category":"type"},{"location":"MassBalanceOpt/#MassBalanceOpt.@components","page":"API","title":"MassBalanceOpt.@components","text":"@components symbols...\n\nCreate and return a component set made up of one or more unquoted symbols.\n\nExamples\n\njulia> comps1 = @components h2 ch4 c2h4\nOrderedSet{Symbol} with 3 elements:\n  :h2\n  :ch4\n  :c2h4\n\njulia> comps1 = @components(h2, ch4, c2h4)\nOrderedSet{Symbol} with 3 elements:\n  :h2\n  :ch4\n  :c2h4\n\nSee also Stream\n\n\n\n\n\n","category":"macro"},{"location":"MassBalanceOpt/#MassBalanceOpt.Stream","page":"API","title":"MassBalanceOpt.Stream","text":"Representation of a material stream in a mass balance model.\n\nStream(name::Symbol, fs, comps; basis=FRAC)\n\nCreate a new Stream with name and components comps in flowsheet fs. The keyword argument basis can be FRAC or FLOW, with FRAC being the default.\n\nCreating a Stream does not create any variables or equations in the model. The stream becomes available for use as an argument to the constructors of blocks, which are subtyped of AbstractBlock. Blocks are responsible for creating stream variables and equations. When a block creates stream variables  it uses the basis of each stream to determine what variables to create. If basis=FRAC a mass fraction variable is created for every component in the stream; if basis=FLOW a component mass flow rate variable is created for every component.\n\nwarning: Warning\nNone of the built-in blocks create equations to sum the mass fractions or the component mass flow rates.\n\nExamples\n\nCreate two inlet streams and one outlet stream, then create a Mixer block that mixes the two inlet streams.\n\njulia> m = Model(); fs = Flowsheet();\n\njulia> in1 = Stream(:in1, fs, @components(h2, ch4))\nStream(in1, fs=index, basis=FRAC, comps=[h2, ch4])\n\njulia> in2 = Stream(:in2, fs, @components(h2, ch4, c2h4), basis=FLOW)\nStream(in2, fs=index, basis=FLOW, comps=[h2, ch4, c2h4])\n\njulia> out = Stream(:out, fs, @components(h2, ch4, c2h4))\nStream(out, fs=index, basis=FRAC, comps=[h2, ch4, c2h4])\n\njulia> mix1 = Mixer(m, :mix1, fs, [in1, in2], out)\nMixer(in=[in1, in2], out=[out])\n\njulia> print_vars(mix1)\n              Name              |    Value   |    Lower   |    Upper   |    Start   |Spec\n--------------------------------|------------|------------|------------|------------|----\nmix1_in1_mass                   |           1|            |            |            |F\nmix1_in1_h2_massfrac            |         0.5|            |            |            |F\nmix1_in1_ch4_massfrac           |         0.5|            |            |            |F\nmix1_in2_mass                   |           1|            |            |            |F\nmix1_in2_h2_mass                |     0.33333|            |            |            |F\nmix1_in2_ch4_mass               |     0.33333|            |            |            |F\nmix1_in2_c2h4_mass              |     0.33333|            |            |            |F\nmix1_out_mass                   |            |            |            |            |\nmix1_out_h2_massfrac            |            |            |            |            |\nmix1_out_ch4_massfrac           |            |            |            |            |\nmix1_out_c2h4_massfrac          |            |            |            |            |\n11 variables\n\nSee also @stream, @streams, Flowsheet, @components, StreamBasis\n\n\n\n\n\n","category":"type"},{"location":"MassBalanceOpt/#MassBalanceOpt.StreamBasis","page":"API","title":"MassBalanceOpt.StreamBasis","text":"@enum StreamBasis\n\nFRAC: Generate mass fraction variables (default). FLOW: Generate component mass flow rate variables.\n\nSee also Stream\n\n\n\n\n\n","category":"type"},{"location":"MassBalanceOpt/#MassBalanceOpt.is_frac","page":"API","title":"MassBalanceOpt.is_frac","text":"is_frac(strm::Stream)\n\nReturn true if the strm basis=FRAC, otherwise return false.\n\nSee also is_flow, StreamBasis\n\n\n\n\n\n","category":"function"},{"location":"MassBalanceOpt/#MassBalanceOpt.is_flow","page":"API","title":"MassBalanceOpt.is_flow","text":"is_flow(strm::Stream)\n\nReturn true if the strm basis=FLOW, otherwise return false.\n\nSee also is_frac, StreamBasis\n\n\n\n\n\n","category":"function"},{"location":"MassBalanceOpt/#MassBalanceOpt.@stream","page":"API","title":"MassBalanceOpt.@stream","text":"@stream(name, comps, ex_basis=:(basis=FRAC))\n\nCreate a Stream named name with component set comps and StreamBasis basis. @stream assumes that the model is stored in a variable named m and the active flowsheet is stored in a variable named fs in the current scope.\n\nExamples\n\njulia> feed = @stream(feed, comps_feed)\n\njulia> prod = @stream(feed, comps_prod, basis=FLOW)\n\nSee also Stream, @streams, StreamBasis\n\n\n\n\n\n","category":"macro"},{"location":"MassBalanceOpt/#MassBalanceOpt.@streams","page":"API","title":"MassBalanceOpt.@streams","text":"@streams(blk)\n\nCreate a tuple of Streams using the expressions in the begin/end block blk. @streams assumes that the model is stored in a variable named m and the active flowsheet is stored in a variable named fs in the current scope.\n\nExamples\n\njulia> (ethfd, profd, cgcout) = @streams(begin\n    ethfd, comps_ethfeed\n    profd, comps_profeed\n    cgcout, comps_cg, (basis=FLOW)\nend)\n\nSee also Stream, @stream, StreamBasis\n\n\n\n\n\n","category":"macro"},{"location":"MassBalanceOpt/#MassBalanceOpt.copy_stream","page":"API","title":"MassBalanceOpt.copy_stream","text":"copy_stream(strm::Stream)\n\nCopy the values of the strm variables in strm's from block into the values of the strm variables in strm's to block. If either the to or from field of strm is empty, do nothing.\n\nSee also copy_streams\n\n\n\n\n\n","category":"function"},{"location":"MassBalanceOpt/#MassBalanceOpt.copy_streams","page":"API","title":"MassBalanceOpt.copy_streams","text":"copy_streams(strms::Vector{Stream})\n\nInvoke copy_stream for each element of strms.\n\nSee also copy_stream\n\n\n\n\n\n","category":"function"},{"location":"MassBalanceOpt/#MassBalanceOpt.make_stream_vars!","page":"API","title":"MassBalanceOpt.make_stream_vars!","text":"make_stream_vars!(m::Model, strm::Stream, prefix::AbstractString, var_list::Vector{VariableRef})\n    -> Dict{Symbol, Any}\n\nCreate stream variables for strm using prefix at the beginning of the variable names. Add the new variables to var_list. Return the stream variables in a dictionary.\n\nSee also Stream, set_stream_var_specs!, make_var!\n\n\n\n\n\nmake_stream_vars!(m::Model, strms::Vector{Stream}, prefix::AbstractString, var_list::Vector{VariableRef})\n    -> Dict{Symbol, Dict}\n\nCreate stream variables for all the streams in the array strms and return them in a dictionary.\n\n\n\n\n\n","category":"function"},{"location":"MassBalanceOpt/#MassBalanceOpt.set_stream_var_specs!","page":"API","title":"MassBalanceOpt.set_stream_var_specs!","text":"set_stream_var_specs!(strms::Vector{Stream}, vars::Dict{Symbol, Dict})\n\nFix the variables stored in vars, for each stream in strms, equal to default values.\n\nSee also Stream, make_stream_vars!, fix\n\n\n\n\n\n","category":"function"},{"location":"MassBalanceOpt/#MassBalanceOpt.Mixer","page":"API","title":"MassBalanceOpt.Mixer","text":"Mixer <: AbstractBlock\n\nMix two or more inlet streams into one outlet stream.\n\nCreate a Mixer block:\n\n    Mixer(m::Model, name::Symbol, fs::Flowsheet, inlets::Vector{Stream}, outlet::Stream)\n\nor if the current scope contains m and fs bound to a Model and Flowsheet:\n\n    @block(name, Mixer, inlets, outlet)\n\nExamples\n\njulia> m = Model(); fs = Flowsheet(); comps = @components A B;\n\njulia> (in1, in2, out) = @streams begin\n           in1, comps\n           in2, comps\n           out, comps\n       end;\n\njulia> mix1 = @block(mix1, Mixer, [in1, in2], out);\n\njulia> print_vars(mix1)\n              Name               Fix      Value          Lower          Upper          Start     \n--------------------------------|---|--------------|--------------|--------------|--------------|\nmix1_in1_mass                     ==              1|              |              |             1|\nmix1_in1_A_massfrac               ==            0.5|              |              |           0.5|\nmix1_in1_B_massfrac               ==            0.5|              |              |           0.5|\nmix1_in2_mass                     ==              1|              |              |             1|\nmix1_in2_A_massfrac               ==            0.5|              |              |           0.5|\nmix1_in2_B_massfrac               ==            0.5|              |              |           0.5|\nmix1_out_mass                                      |              |              |              |\nmix1_out_A_massfrac                                |              |              |              |\nmix1_out_B_massfrac                                |              |              |              |\n9 variables\n\nSee also Stream, Splitter, Separator, YieldReactor, MultiYieldReactor, StoicReactor\n\n\n\n\n\n","category":"type"},{"location":"MassBalanceOpt/#MassBalanceOpt.Splitter","page":"API","title":"MassBalanceOpt.Splitter","text":"Splitter <: AbstractBlock\n\nSplit one inlet stream into two or more outlet streams.\n\nCreate a Splitter block:\n\n    Splitter(m::Model, name::Symbol, fs::Flowsheet, inlet::Stream, outlets::Vector{Stream})\n\nor if the current scope contains m and fs bound to a Model and Flowsheet:\n\n    @block(name, Splitter, inlet, outlets)\n\nExamples\n\njulia> m = Model(); fs = Flowsheet(); comps = @components A B;\n\njulia> (in1, out1, out2) = @streams begin\n           in1, comps\n           out1, comps\n           out2, comps\n       end;\n\njulia> spl = @block(spl, Splitter, in1, [out1, out2]);\n\njulia> print_vars(spl)\n              Name               Fix      Value          Lower          Upper          Start     \n--------------------------------|---|--------------|--------------|--------------|--------------|\nspl_in1_mass                      ==              1|              |              |             1|\nspl_in1_A_massfrac                ==            0.5|              |              |           0.5|\nspl_in1_B_massfrac                ==            0.5|              |              |           0.5|\nspl_out1_mass                                      |              |              |              |\nspl_out1_A_massfrac                                |              |              |              |\nspl_out1_B_massfrac                                |              |              |              |\nspl_out2_mass                                      |              |              |              |\nspl_out2_A_massfrac                                |              |              |              |\nspl_out2_B_massfrac                                |              |              |              |\nspl_out1_split_frac               ==            0.5|              |              |           0.5|\nspl_out2_split_frac                                |              |              |           0.5|\n11 variables\n\nSee also Stream, Mixer, Separator, YieldReactor, MultiYieldReactor, StoicReactor\n\n\n\n\n\n","category":"type"},{"location":"MassBalanceOpt/#MassBalanceOpt.Separator","page":"API","title":"MassBalanceOpt.Separator","text":"Separator <: AbstractBlock\n\nSeparate the components in the inlet stream into two or more outlet streams.\n\nCreate a Separator block:\n\n    Separator(m::Model, name::Symbol, fs::Flowsheet, inlet::Stream, outlets::Vector{Stream})\n\nor if the current scope contains m and fs bound to a Model and Flowsheet:\n\n    @block(name, Separator, inlet, outlets)\n\nExamples\n\njulia> m = Model(); fs = Flowsheet(); comps = @components A B;\n\njulia> (in1, out1, out2) = @streams begin\n    in1, comps\n    out1, comps\n    out2, comps\nend;\n\njulia> sep = @block(sep, Separator, in1, [out1, out2]);\n\njulia> @set sep_A_out1_split = 0.3\n\njulia> @set sep_B_out1_split = 0.6\n\njulia> set_start_values(sep)\n\njulia> print_vars(sep)\n              Name               Fix      Value          Lower          Upper          Start     \n--------------------------------|---|--------------|--------------|--------------|--------------|\nsep_in1_mass                      ==              1|              |              |             1|\nsep_in1_A_massfrac                ==            0.5|              |              |           0.5|\nsep_in1_B_massfrac                ==            0.5|              |              |           0.5|\nsep_out1_mass                                      |              |              |          0.45|\nsep_out1_A_massfrac                                |              |              |     0.3333333|\nsep_out1_B_massfrac                                |              |              |     0.6666667|\nsep_out2_mass                                      |              |              |          0.55|\nsep_out2_A_massfrac                                |              |              |     0.6363636|\nsep_out2_B_massfrac                                |              |              |     0.3636364|\nsep_in1_A_mass                                     |              |              |           0.5|\nsep_in1_B_mass                                     |              |              |           0.5|\nsep_out1_A_mass                                    |              |              |          0.15|\nsep_out1_B_mass                                    |              |              |           0.3|\nsep_out2_A_mass                                    |              |              |          0.35|\nsep_out2_B_mass                                    |              |              |           0.2|\nsep_A_out1_split                  ==            0.3|              |              |           0.3|\nsep_A_out2_split                                   |              |              |           0.7|\nsep_B_out1_split                  ==            0.6|              |              |           0.6|\nsep_B_out2_split                                   |              |              |           0.4|\n19 variables\n\nSee also Stream, Mixer, Splitter, YieldReactor, MultiYieldReactor, StoicReactor\n\n\n\n\n\n","category":"type"},{"location":"MassBalanceOpt/#MassBalanceOpt.@stoic","page":"API","title":"MassBalanceOpt.@stoic","text":"@stoic(expr)\n\nCreate an array of OrderedDicts, each of which encodes the stoichiometric coefficients of a single reaction. The expr should be one or more balanced chemical reactions written in the form:\n\naA + bB + ... => cC + dD\n\nwhere a, b, etc. are real or integer stoichiometric coefficients, and A, B, etc. are species. The returned array looks like:\n\ncoef[1] = OrderedDict(:A => -a, :B => -b, :C => c, :D => d)   # coefficients for reaction 1\ncoef[2] = OrderedDict(:A => -a, :B => -b, :C => c, :D => d)   # coefficients for reaction 2\n  ...\n\nNote that the coefficients in the OrderedDict are positive for products and negative for reactants.\n\nExamples\n\njulia> coef = @stoic A + B => C\njulia> coef\n1-element Vector{OrderedCollections.OrderedDict{Symbol, Real}}:\n OrderedCollections.OrderedDict(:A => -1, :B => -1, :C => 1)\n\njulia> @stoic begin\n        A + B => C\n      2A + 3B => 4C + D\n    end\n2-element Vector{OrderedCollections.OrderedDict{Symbol, Real}}:\nOrderedCollections.OrderedDict(:A => -1, :B => -1, :C => 1)\nOrderedCollections.OrderedDict(:A => -2, :B => -3, :C => 4, :D => 1)\n\nSee also StoicReactor\n\n\n\n\n\n","category":"macro"},{"location":"MassBalanceOpt/#MassBalanceOpt.StoicReactor","page":"API","title":"MassBalanceOpt.StoicReactor","text":"StoicReactor <: AbstractBlock\n\nModel a reactor in which a set of stoichiometric reactions with specified conversions takes place.\n\nCreate a StoicReactor block:\n\n    StoicReactor(m::Model, name::Symbol, fs::Flowsheet, inlet::Stream, outlet::Stream,\n        stoic_coef::Vector{OrderedDict{Symbol, Real}}, \n        mw::Dict{Symbol, Float64},\n        conv::OrderedDict{Int, NamedTuple{(:c, :X), Tuple{Symbol, Float64}}}= OrderedDict{Int, NamedTuple{(:c, :X),\n                               Tuple{Symbol, Float64}}}())\n\nor if the current scope contains m and fs bound to a Model and Flowsheet:\n\n    @block(name, StoicReactor, inlet, outlet, stoic_coef, mw, conv)\n\nExamples\n\njulia> m = Model(); fs = Flowsheet(); comps1 = @components A B; comps2 = @components A B C D;\n\njulia> (in1, out1) = @streams begin\n    in1, comps1\n    out1, comps2\nend;\n\njulia> mw = Dict(:A => 30.0, :B => 28.0, :C => 35.0, :D => 30.0);\n\njulia> coef = @stoic A + B => C + D\n1-element Vector{OrderedDict{Symbol, Real}}:\n OrderedDict(:A => -1, :B => -1, :C => 1, :D => 1)\n\n julia> conv = OrderedDict(1 => (c=:A, X=0.65))\n OrderedDict{Int64, NamedTuple{(:c, :X), Tuple{Symbol, Float64}}} with 1 entry:\n   1 => (c = :A, X = 0.65)\n   \njulia> r1 = @block(r1, StoicReactor, in1, out1, coef, mw, conv);\n\njulia> print_vars(r1)\n              Name               Fix      Value          Lower          Upper          Start     \n--------------------------------|---|--------------|--------------|--------------|--------------|\nr1_in1_mass                       ==              1|              |              |             1|\nr1_in1_A_massfrac                 ==            0.5|              |              |           0.5|\nr1_in1_B_massfrac                 ==            0.5|              |              |           0.5|\nr1_out1_mass                                       |              |              |              |\nr1_out1_A_massfrac                                 |              |              |              |\nr1_out1_B_massfrac                                 |              |              |              |\nr1_out1_C_massfrac                                 |              |              |              |\nr1_out1_D_massfrac                                 |              |              |              |\nr1_in1_A_mass                                      |              |              |              |\nr1_in1_B_mass                                      |              |              |              |\nr1_out1_A_mass                                     |              |              |              |\nr1_out1_B_mass                                     |              |              |              |\nr1_out1_C_mass                                     |              |              |              |\nr1_out1_D_mass                                     |              |              |              |\nr1_in1_A_moles                                     |              |              |              |\nr1_in1_B_moles                                     |              |              |              |\nr1_out1_A_moles                                    |              |              |              |\nr1_out1_B_moles                                    |              |              |              |\nr1_out1_C_moles                                    |              |              |              |\nr1_out1_D_moles                                    |              |              |              |\nr1_extent_rx_1                                     |              |              |              |\nr1_conv_A_rx_1                    ==           0.65|              |              |          0.65|\n22 variables\n\nSee also @stoic, Stream, YieldReactor, MultiYieldReactor\n\n\n\n\n\n","category":"type"},{"location":"MassBalanceOpt/#MassBalanceOpt.YieldReactor","page":"API","title":"MassBalanceOpt.YieldReactor","text":"YieldReactor <: AbstractBlock\n\nModel a reactor with one inlet and one outlet stream, in which each component in the inlet stream has a specified yield to the components in the outlet stream.\n\nCreate a YieldReactor block:\n\n    YieldReactor(m::Model, name::Symbol, fs::Flowsheet, inlet::Stream, outlet::Stream)\n\njulia or if the current scope contains m and fs bound to a Model and Flowsheet:\n\n    @block(name, YieldReactor, inlet, outlet)\n\nExamples\n\njulia> m = Model(); fs = Flowsheet(); comps1 = @components A B; comps2 = @components A B C D;\n\njulia> (in1, out1) = @streams begin\n    in1, comps1\n    out1, comps2\nend;\n\njulia> r1 = @block(r1, YieldReactor, in1, out1);\n\njulia> @set begin\n    r1_y_C_from_A = 0.3\n    r1_y_D_from_A = 0.4\n    r1_y_C_from_B = 0.6\n    r1_y_D_from_B = 0.1\nend\n\njulia> set_start_values(r1)\n\njulia> print_vars(r1)\nName                             Fix      Value          Lower          Upper          Start     \n--------------------------------|---|--------------|--------------|--------------|--------------|\nr1_in1_mass                       ==              1|              |              |             1|\nr1_in1_A_massfrac                 ==            0.5|              |              |           0.5|\nr1_in1_B_massfrac                 ==            0.5|              |              |           0.5|\nr1_out1_mass                                       |              |              |             1|\nr1_out1_A_massfrac                                 |              |              |          0.15|\nr1_out1_B_massfrac                                 |              |              |          0.15|\nr1_out1_C_massfrac                                 |              |              |          0.45|\nr1_out1_D_massfrac                                 |              |              |          0.25|\nr1_in1_A_mass                                      |              |              |           0.5|\nr1_in1_B_mass                                      |              |              |           0.5|\nr1_out1_A_mass                                     |              |              |          0.15|\nr1_out1_B_mass                                     |              |              |          0.15|\nr1_out1_C_mass                                     |              |              |          0.45|\nr1_out1_D_mass                                     |              |              |          0.25|\nr1_y_A_from_A                                      |              |              |           0.3|\nr1_y_B_from_A                     ==              0|              |              |             0|\nr1_y_C_from_A                     ==            0.3|              |              |           0.3|\nr1_y_D_from_A                     ==            0.4|              |              |           0.4|\nr1_y_A_from_B                     ==              0|              |              |             0|\nr1_y_B_from_B                                      |              |              |           0.3|\nr1_y_C_from_B                     ==            0.6|              |              |           0.6|\nr1_y_D_from_B                     ==            0.1|              |              |           0.1|\n22 variables\n\nSee also Stream, MultiYieldReactor, StoicReactor\n\n\n\n\n\n","category":"type"},{"location":"MassBalanceOpt/#MassBalanceOpt.MultiYieldReactor","page":"API","title":"MassBalanceOpt.MultiYieldReactor","text":"MultiYieldReactor <: AbstractBlock\n\nModel a reactor with multiple inlet and outlet streams. This is used to represent a set of YieldReactors operating in parallel. The number of inlet streams must equal the number of outlet streams, and the length of feed_names must equal the number of streams.\n\nCreate a MultiYieldReactor block:\n\n    MultiYieldReactor(m::Model, name::Symbol, fs::Flowsheet, inlets::Vector{Stream}, outlets::Vector{Stream},\n         feed_names::Vector{Symbol}, reactor_name::Symbol)\n\nor if the current scope contains m and fs bound to a Model and Flowsheet:\n\n    @block(name, MultiYieldReactor, inlets, outlets, feed_names, reactor_name)\n\nExamples\n\njulia> m = Model(); fs = Flowsheet();\n\njulia> compsA = @components(A); compsB = @components(B); comps_out = @components A B C D;\n\njulia> (feedA, feedB, outA, outB) = @streams begin\n    feedA, compsA\n    feedB, compsB\n    outA , comps_out\n    outB , comps_out\nend;\n\njulia> r1 = @block(r1, MultiYieldReactor, [feedA, feedB], [outA, outB], [:feedA, :feedB], :rx);\n\njulia> print_vars(r1)\n              Name               Fix      Value          Lower          Upper          Start     \n--------------------------------|---|--------------|--------------|--------------|--------------|\nr1_feedA_mass                     ==              1|              |              |             1|\nr1_feedA_A_massfrac               ==              1|              |              |             1|\nr1_feedB_mass                     ==              1|              |              |             1|\nr1_feedB_B_massfrac               ==              1|              |              |             1|\nr1_outA_mass                                       |              |              |              |\nr1_outA_A_massfrac                                 |              |              |              |\nr1_outA_B_massfrac                                 |              |              |              |\nr1_outA_C_massfrac                                 |              |              |              |\nr1_outA_D_massfrac                                 |              |              |              |\nr1_outB_mass                                       |              |              |              |\nr1_outB_A_massfrac                                 |              |              |              |\nr1_outB_B_massfrac                                 |              |              |              |\nr1_outB_C_massfrac                                 |              |              |              |\nr1_outB_D_massfrac                                 |              |              |              |\nr1_feedA_A_mass                                    |              |              |              |\nr1_feedB_B_mass                                    |              |              |              |\nr1_outA_A_mass                                     |              |              |              |\nr1_outA_B_mass                                     |              |              |              |\nr1_outA_C_mass                                     |              |              |              |\nr1_outA_D_mass                                     |              |              |              |\nr1_outB_A_mass                                     |              |              |              |\nr1_outB_B_mass                                     |              |              |              |\nr1_outB_C_mass                                     |              |              |              |\nr1_outB_D_mass                                     |              |              |              |\nr1_total_feed_mass                                 |              |              |              |\nr1_feedA_n_rx                                      |              |              |              |\nr1_feedA_rate                     ==              1|              |              |             1|\nr1_feedB_n_rx                                      |              |              |              |\nr1_feedB_rate                     ==              1|              |              |             1|\nr1_n_rx                                            |              |              |              |\nr1_feedA_y_A_from_A                                |              |              |             0|\nr1_feedA_y_B_from_A               ==              0|              |              |             0|\nr1_feedA_y_C_from_A               ==              0|              |              |             0|\nr1_feedA_y_D_from_A               ==              0|              |              |             0|\nr1_feedB_y_A_from_B               ==              0|              |              |             0|\nr1_feedB_y_B_from_B                                |              |              |             0|\nr1_feedB_y_C_from_B               ==              0|              |              |             0|\nr1_feedB_y_D_from_B               ==              0|              |              |             0|\n38 variables\n\nSee also Stream, YieldReactor, StoicReactor\n\n\n\n\n\n","category":"type"},{"location":"MassBalanceOpt/#MassBalanceOpt.@block","page":"API","title":"MassBalanceOpt.@block","text":"@block(name, kind, args...)\n\nCreate a block named name with type kind in flowsheet fs using arguments args.... The value of kind must be a subtype of AbstractBlock. @block assumes that the model is stored in a variable named m and the active flowsheet is stored in a variable named fs in the current scope.\n\nExamples\n\njulia> ctdc1 = @block(ctdc1, Separator, arxo, [offgas, dc1bt])\n\njulia> arx = @block(arx, StoicReactor, dc2oh, arxo, arx_stoic, arx_mw, arx_conv)\n\nSee also Mixer, Splitter, Separator, YieldReactor,     MultiYieldReactor, StoicReactor\n\n\n\n\n\n","category":"macro"},{"location":"MassBalanceOpt/#MassBalanceOpt.@Block_fields","page":"API","title":"MassBalanceOpt.@Block_fields","text":"@Block_fields\n\nCreate the fields typically used in a block. They are:\n\n    name::Symbol\n    fs::Flowsheet\n    inlets::Vector{Stream}\n    outlets::Vector{Stream}\n    strm_vars::Dict{Symbol, Dict}\n    var_list::Vector{VariableRef}\n    eq_list::Vector{ConstraintRef}\n\nSee also AbstractBlock, @Block_init, @Block_finish\n\n\n\n\n\n","category":"macro"},{"location":"MassBalanceOpt/#MassBalanceOpt.@Block_init","page":"API","title":"MassBalanceOpt.@Block_init","text":"@Block_init\n\nCreate the stream variables used in a block and set their specs.\n\nSee also AbstractBlock, @Block_fields, @Block_finish\n\n\n\n\n\n","category":"macro"},{"location":"MassBalanceOpt/#MassBalanceOpt.@Block_finish","page":"API","title":"MassBalanceOpt.@Block_finish","text":"@Block_finish\n\nAssign a newly created block referenced by self to its container flowsheet, and record the block in the to and from fields of the inlet and outlet streams.\n\nSee also AbstractBlock, @Block_fields, @Block_init\n\n\n\n\n\n","category":"macro"},{"location":"MassBalanceOpt/#MassBalanceOpt.make_mass_flow_vars!","page":"API","title":"MassBalanceOpt.make_mass_flow_vars!","text":"make_mass_flow_vars!(m::Model,\n                     prefix::AbstractString,\n                     inlets::Vector{Stream},\n                     outlets::Vector{Stream},\n                     strm_vars::Dict{Symbol, Dict},\n                     var_list::Vector{VariableRef},\n                     eq_list::Vector{ConstraintRef})::Dict{Symbol, Dict}\n\nConditionally create component mass flow rate variables for the streams in inlets and outlets. If the stream has a FLOW basis, component mass flow rate variables already exist. If the stream has a FRAC basis, make new component mass flow variables and equations to calculate them. Add equations to calculate the outlet stream total mass flow rates from the component mass flow rates.\n\n\n\n\n\n","category":"function"},{"location":"MassBalanceOpt/#JuMP.set_start_values-Tuple{AbstractBlock}","page":"API","title":"JuMP.set_start_values","text":"set_start_values(blk::AbstractBlock; copy_inlets::Bool=true)\n\nSet the start values of the block variables in blk. If copy_inlets=false, don't copy the inlet stream variable start values from the upstream block.\n\n\n\n\n\n","category":"method"},{"location":"MassBalanceOpt/#Variables-and-Equations","page":"API","title":"Variables and Equations","text":"","category":"section"},{"location":"MassBalanceOpt/#MassBalanceOpt.make_var!","page":"API","title":"MassBalanceOpt.make_var!","text":"make_var!(m::Model, name::AbstractString, var_list::Vector{VariableRef})\n\nCreate a new JuMP variable named name, register it in model m as m[:name], and add it to var_list.\n\n\n\n\n\n","category":"function"},{"location":"MassBalanceOpt/#JuMP.fix-Tuple{VariableRef}","page":"API","title":"JuMP.fix","text":"fix(var::VariableRef, [val::Real])\n\nIf val is passed, fix the variable var equal to val and set its start value to val. If no val is passed, fix the variable equal to its value in the most recent solution. If no solution is available, fix the variable equal to its start value. If no start value is available, fix the variable equal to 0.\n\nSee also free, @specs\n\n\n\n\n\n","category":"method"},{"location":"MassBalanceOpt/#MassBalanceOpt.free","page":"API","title":"MassBalanceOpt.free","text":"free(var::VariableRef)\n\nDelete the fixing constraint for variable var.\n\nSee also fix, @specs\n\n\n\n\n\n","category":"function"},{"location":"MassBalanceOpt/#MassBalanceOpt.flip","page":"API","title":"MassBalanceOpt.flip","text":"flip(var1::VariableRef, [var2::VariableRef])\n\nIf var2 is passed, invert the specs of var1 and var2, i.e., if var1 is fixed and var2 is free, make var1 free and var2 fixed; if var1 is free and var2 is fixed, make var1 fixed and var2 free. If both vars have the same spec, do nothing.\n\nIf var2 is not passed, invert the spec of var1.\n\nwarning: Warning\nThe newly fixed variable will have its value set to:1. its value in the most recent solution\n2. its start value\n3. 0in that order. Use set_value or @set to change the value of the newly fixed variable.\n\nSee also @set, @specs\n\n\n\n\n\n","category":"function"},{"location":"MassBalanceOpt/#MassBalanceOpt.connect","page":"API","title":"MassBalanceOpt.connect","text":"connect(var_lhs::VariableRef, var_rhs::VariableRef)\n\nGiven two variables var_lhs and var_rhs, at least one of which is fixed, add a new constraint:\n\nvar_lhs == var_rhs\n\nIf both variables are fixed, free var_rhs. Otherwise free the single fixed variable. If both variables are free, don't add a new constraint and return nothing.\n\nReturn the newly created ConstraintRef. See also @set\n\n\n\n\n\nconnect(strm::Stream)\n\nConnect all the variables in the source and destination blocks of strm. If the stream has no source, or no destination, do nothing.\n\n\n\n\n\nconnect(m::Model, strms::Vector{Stream})\n\nConnect all the streams in the array strms.\n\n\n\n\n\nconnect(fs::Flowsheet)\n\nConnect all the streams in the flowsheet fs.\n\n\n\n\n\n","category":"function"},{"location":"MassBalanceOpt/#JuMP.set_value-Tuple{VariableRef, Real}","page":"API","title":"JuMP.set_value","text":"set_value(var::VariableRef, val::Real)\n\nIf var is fixed, reset its fixed value to val. If var is free, set its start value to val.\n\nSee also fix, @set, @values\n\n\n\n\n\n","category":"method"},{"location":"MassBalanceOpt/#MassBalanceOpt.set_lower","page":"API","title":"MassBalanceOpt.set_lower","text":"set_lower(var::VariableRef, lower::Real)\n\nIf var is not fixed, set its lower bound to lower.\n\nSee also set_upper, delete_lower\n\n\n\n\n\n","category":"function"},{"location":"MassBalanceOpt/#MassBalanceOpt.set_upper","page":"API","title":"MassBalanceOpt.set_upper","text":"set_upper(var::VariableRef, lower::Real)\n\nIf var is not fixed, set its upper bound to upper.\n\nSee also set_lower, delete_upper\n\n\n\n\n\n","category":"function"},{"location":"MassBalanceOpt/#MassBalanceOpt.delete_lower","page":"API","title":"MassBalanceOpt.delete_lower","text":"delete_lower(var::VariableRef)\n\nIf var is not fixed and has a lower bound, delete its lower bound.\n\nSee also set_lower, delete_upper\n\n\n\n\n\n","category":"function"},{"location":"MassBalanceOpt/#MassBalanceOpt.delete_upper","page":"API","title":"MassBalanceOpt.delete_upper","text":"delete_upper(var::VariableRef)\n\nIf var is not fixed and has an upper bound, delete its upper bound.\n\nSee also set_upper, delete_lower\n\n\n\n\n\n","category":"function"},{"location":"MassBalanceOpt/#MassBalanceOpt.@set","page":"API","title":"MassBalanceOpt.@set","text":"@set expr\n\nDo the operations described by expr (see examples below). @set assumes that the model is stored in a variable named m in the current scope.\n\nExamples\n\nSet the value of the variable var to 100.0. If the variable is fixed, set the fixed value to 100.0, otherwise set the start value to 100.0:\n\njulia> @set var = 100.0\n\nConnect variables var1 and var2. This adds the equation var1 == var2 to the model. At least one of the variables must be fixed:\n\njulia> @set var1 = var2\n\nSet the upper bound on var to 100.0:\n\njulia> @set var <= 100.0\n\nSet the upper bound on var to 100.0:\n\njulia> @set var <= 100.0\n\nDelete the upper bound on var:\n\njulia> @set var <= Inf\n\nDelete the lower bound on var:\n\njulia> @set -Inf <= var\n\nDelete the lower and upper bounds on var:\n\njulia> @set -Inf <= var <= Inf\n\nFlip the specs on var1 and var2. If var1 is fixed and var2 is free, free var1 and fix var2. If var1 is free and var2 is fixed, fix var1 and free var2. If both variables have the same spec, do nothing:\n\njulia> @set var1 ~ var2\n\nFlip the spec on var. If var is fixed, free var. If var is free, fix var:\n\njulia> @set ~var\n\nFix var:\n\njulia> @set +var\n\nFree var:\n\njulia> @set -var\n\nSet the lower and upper bounds on var:\n\njulia> @set 1.0 < var < 2.0\njulia> @set 2.0 > var > 1.0\n\nCombine several operations in a begin/end block:\n\njulia> @set begin\n    x > 1.0\n    y < 2.0\n    1.0 < z < 2.0\n    p ~ q\nend\n\nSee also @values, @specs, @bounds\n\n\n\n\n\n","category":"macro"},{"location":"MassBalanceOpt/#MassBalanceOpt.@values","page":"API","title":"MassBalanceOpt.@values","text":"@values expr\n\nAlias for @set.\n\nSee also @set, @specs, @bounds\n\n\n\n\n\n","category":"macro"},{"location":"MassBalanceOpt/#MassBalanceOpt.@specs","page":"API","title":"MassBalanceOpt.@specs","text":"@specs expr\n\nAlias for @set.\n\nSee also @set, @values, @bounds\n\n\n\n\n\n","category":"macro"},{"location":"MassBalanceOpt/#MassBalanceOpt.@bounds","page":"API","title":"MassBalanceOpt.@bounds","text":"@bounds expr\n\nAlias for @set.\n\nSee also @set, @values, @specs\n\n\n\n\n\n","category":"macro"},{"location":"MassBalanceOpt/#MassBalanceOpt.make_eq!","page":"API","title":"MassBalanceOpt.make_eq!","text":"make_eq!(m::Model, name::AbstractString, con::ConstraintRef, eq_list::Vector{ConstraintRef})\n\nRegister the equation con in model m using name as the base name. Add the equation to eq_list.\n\nSee also make_var!\n\n\n\n\n\n","category":"function"},{"location":"MassBalanceOpt/#Printing-and-Output","page":"API","title":"Printing and Output","text":"","category":"section"},{"location":"MassBalanceOpt/#MassBalanceOpt.print_vars","page":"API","title":"MassBalanceOpt.print_vars","text":"print_vars([io::IO], vars::Vector{VariableRef})\n\nPrint the variables in vars in a table.\n\nSee also print_fixed, print_free, print_bounds, print_active, print_eqs,     write_vars\n\n\n\n\n\nprint_vars([io::IO], var::VariableRef)\n\nPrint a single variable var.\n\n\n\n\n\nprint_vars([io::IO], m::Model)\n\nPrint all the variables in model m.\n\n\n\n\n\nprint_vars([io::IO], blk::AbstractBlock)\n\nPrint all the variables in block blk.\n\n\n\n\n\nprint_vars([io::IO], m::Model, glob::AbstractString)\n\nPrint the variables in model m that match glob, where glob is a string containing one or more * wildcard characters.\n\nExamples\n\njulia> print_vars(m, \"*mass\")\n\njulia> print_vars(m, \"*cgcfeed*\")\n\n\n\n\n\nprint_vars([io::IO], m::Model, pattern::Regex)\n\nPrint the variables in model m that match the regular expression pattern.\n\nExamples\n\njulia> print_vars(m, r\"^.*mass$\")\n\n\n\n\n\n","category":"function"},{"location":"MassBalanceOpt/#MassBalanceOpt.write_vars","page":"API","title":"MassBalanceOpt.write_vars","text":"write_vars([io::IO], m::Model)\n\nWrite the values of all the variables in m to io in the format:\n\n@values begin\n    var_1 = 1.0\n    var_2 = 2.0\n     ...\nend\n\n\n\n\n\n","category":"function"},{"location":"MassBalanceOpt/#MassBalanceOpt.print_fixed","page":"API","title":"MassBalanceOpt.print_fixed","text":"print_fixed([io::IO], m::Model)\n\nPrint all the fixed variables in model m.\n\nSee also print_free, print_bounds, print_active\n\n\n\n\n\nprint_fixed([io::IO], blk::AbstractBlock)\n\nPrint all the fixed variables in block blk.\n\n\n\n\n\n","category":"function"},{"location":"MassBalanceOpt/#MassBalanceOpt.print_free","page":"API","title":"MassBalanceOpt.print_free","text":"print_free([io::IO], m::Model)\n\nPrint all the free variables in model m.\n\nSee also print_fixed, print_bounds, print_active\n\n\n\n\n\nprint_free([op::IO], blk::AbstractBlock)\n\nPrint all the free variables in block blk.\n\n\n\n\n\n","category":"function"},{"location":"MassBalanceOpt/#MassBalanceOpt.print_bounds","page":"API","title":"MassBalanceOpt.print_bounds","text":"print_bounds([io::IO], m::Model)\n\nPrint the variables in m with lower or upper bounds.\n\nSee also print_fixed, print_free, print_active\n\n\n\n\n\nprint_bounds([io::IO], blk::AbstractBlock)\n\nPrint the variables in blk with lower or upper bounds.\n\n\n\n\n\n","category":"function"},{"location":"MassBalanceOpt/#MassBalanceOpt.print_active","page":"API","title":"MassBalanceOpt.print_active","text":"print_active([io::IO], m::Model)\n\nPrint the variables in m whose values equal their lower or upper bounds.\n\nSee also print_fixed, print_free, print_bounds\n\n\n\n\n\n","category":"function"},{"location":"MassBalanceOpt/#MassBalanceOpt.print_eqs","page":"API","title":"MassBalanceOpt.print_eqs","text":"print_eqs([io::IO], m::Model)\n\nPrint all the equations in model m.\n\nSee also print_vars\n\n\n\n\n\nprint_eqs([io::IO], blk::AbstractBlock)\n\nPrint all the equations in block blk.\n\n\n\n\n\nprint_eqs([io::IO], m::Model, eq::Symbol)\n\nPrint the equation registered in model m as m[:eq]\n\n\n\n\n\n","category":"function"},{"location":"MassBalanceOpt/#MassBalanceOpt.print_model","page":"API","title":"MassBalanceOpt.print_model","text":"print_model([io::IO], model_or_block::Union{Model, AbstractBlock})\n\nPrint all the variables and equations in a model or block specified by model_or_block.\n\nSee also print_vars, print_eqs\n\n\n\n\n\n","category":"function"},{"location":"MassBalanceOpt/#Solving-Models","page":"API","title":"Solving Models","text":"","category":"section"},{"location":"MassBalanceOpt/#MassBalanceOpt.@solve","page":"API","title":"MassBalanceOpt.@solve","text":"@solve\n\nRun the function optimize!(m) where m is a JuMP model in the current scope.\n\n\n\n\n\n","category":"macro"},{"location":"MassBalanceOpt/#MassBalanceOpt.eval_obj","page":"API","title":"MassBalanceOpt.eval_obj","text":"eval_obj(m::Model)\n\nEvalulate the objective function in m, using the solution values if a solution exists, otherwise using the start values.\n\n\n\n\n\n","category":"function"},{"location":"MassBalanceOpt/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"MassBalanceOpt/","page":"API","title":"API","text":"","category":"page"},{"location":"Examples/#Mixer,-StoicReactor,-Separator","page":"Examples","title":"Mixer, StoicReactor, Separator","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"This is an example of a simple flowsheet with a Mixer, StoicReactor, and Separator.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Add the package from the Julia REPL in the usual way; type ] to enter the Pkg REPL mode and run","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"pkg> add MassBalanceOpt","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"To do anything useful you'll also need three other packages:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"pkg> add JuMP Ipopt OrderedCollections","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Then import the packages:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using MassBalanceOpt, JuMP, Ipopt, OrderedCollections","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Create a JuMP model and a Flowsheet to hold the blocks and streams:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"m = Model(Ipopt.Optimizer); fs = Flowsheet();","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Suppose we have a feed stream of pure component A that mixes with a recycle stream and is fed to a reactor, where the reaction A => B + C takes place with a specified conversion of component A. The reactor effluent is fed to a distillation column where component C and most of B goes overhead, with unreacted A and a small amount of B going out the bottom and back to the feed header. To create the streams we need to first make some component groups:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"c_A   = @components A\nc_AB  = @components A B\nc_BC  = @components B C\nc_all = @components A B C","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Now we can create the feed, recycle, and reactor inlet streams:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(feed, recycle, rx_in) = @streams begin\n    feed   , c_A\n    recycle, c_AB\n    rx_in  , c_AB\nend","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The feed and recycle streams flow into a Mixer block named feedhdr:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"feedhdr = @block(feedhdr, Mixer, [feed, recycle], rx_in)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Here's what the model looks like so far:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"print_model(m)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The two inlet streams to feedhdr have fixed flow rates and compositions that are set to default values when the block was created. The recycle stream flow rate and composition will eventually become free variables after the rest of the model is built, but right now we need to provide values for the fixed variables:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"@values begin\n    feedhdr_feed_mass          = 10_000.0\n    feedhdr_recycle_mass       = 2_000.0\n    feedhdr_recycle_A_massfrac = 0.99\n    feedhdr_recycle_B_massfrac = 0.01\nend\nprint_fixed(m)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Now we can estimate start values for the free variables in block feedhdr:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"set_start_values(feedhdr)\nprint_vars(m)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Now we can create the reactor outlet stream and the reactor block:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"rx_out = @stream(rx_out, c_all)\nrx_stoic = @stoic A => B + C    # Reaction stoichiometry\nmw = Dict(:A => 30.0, :B => 15.0, :C => 10.0)    # Molecular weights\nconv = OrderedDict(1 => (c=:A, X=0.8))    # Conversion in reaction 1 (A => B + C)\nrx = @block(rx, StoicReactor, rx_in, rx_out, rx_stoic, mw, conv)\nprint_vars(rx)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Notice that the reactor inlet stream mass flow rate and composition are fixed to default values. We need to connect the stream rx_in so that the mass flow rate and composition of stream rx_in in block rx are equal to the mass flow rate and composition of rx_in in block feedhdr. Then we can estimate the start values and solve the model:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"connect(rx_in)\nset_start_values(rx)\n@solve\nprint_vars(m)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The solver converged immediately because the start value estimates were equal to the values at the solution. This won't always be the case. Now we can create the block that models the distillation column:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"product = @stream(product, c_BC)\ncol = @block(col, Separator, rx_out, [product, recycle])\nprint_fixed(col)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"We connect the stream rx_out and set the value of the split fraction of component B into the recycle stream. We don't need to specify split fractions for A or C because the component set specifications force all A into the recycle stream and all C into the product stream.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"connect(rx_out)\n@set col_B_recycle_split = 0.01\nset_start_values(col)\n@solve\nprint_vars(col)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"We don't really want to fix col_B_recycle_split though. A controller will be controlling the mass fraction of B in the recycle stream to a setpoint, so we want to fix the B mass fraction in the recycle stream and free col_B_recycle_split. This is called \"flipping\" the specs on the two variables, and is done like this:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"@specs col_B_recycle_split ~ col_recycle_B_massfrac\n@set col_recycle_B_massfrac = 0.01    # Set the mass fraction of B in the recycle stream\n@solve\nprint_vars(col)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Finally we can connect the recycle stream and solve the complete problem:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"connect(recycle)\n@solve\nprint_vars(m)","category":"page"},{"location":"Examples/#Simple-Ethylene-Plant","page":"Examples","title":"Simple Ethylene Plant","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"This is an example of the use of the MassBalanceOpt package to build a simple model of an ethylene plant and solve it with JuMP. Here is a block diagram of the flowsheet:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Create a JuMP model that uses the Ipopt solver:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"m = Model(Ipopt.Optimizer)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Create a Flowsheet to contain the variables and equations of the model. The default name of a flowsheet is :index. The :index flowsheet does not have a parent flowsheet.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"fs = Flowsheet()","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The plant will have two feed streams: ethane and propane, each containing only one component. A component is simply a Symbol; it doesn't have any attributes like a chemical formula or molecular weight.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"comps_eth_feed = @components c2h6\ncomps_pro_feed = @components c3h8","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The feed streams are mixed with ethane and propane recycle streams. The component sets for the recycle streams are:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"comps_eth_rec = @components c2h4 c2h6\ncomps_pro_rec = @components c3h6 c3h8 mapd","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The fresh feed streams are mixed with their recycle streams in Mixer blocks. These blocks need streams for the fresh feeds, recycles, and the mixed feed/recycle:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(ethfd, ethre, ethf1f5, profd, prore, prof1f5) = @streams begin\n        ethfd   , comps_eth_feed   # Ethane fresh feed\n        ethre   , comps_eth_rec    # Ethane recycle\n        ethf1f5 , comps_eth_rec    # Mixed fresh ethane feed and ethane recycle to furnaces F-1 through F-5.\n        profd   , comps_pro_feed   # Propane fresh feed\n        prore   , comps_pro_rec    # Propane recycle\n        prof1f5 , comps_pro_rec    # Mixed fresh propane feed and propane recycle to furnaces F-1 through F-5.\n    end","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Create Mixer blocks that represent the ethane and propane feed headers:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"ethhdr = @block(ethhdr, Mixer, [ethfd, ethre], ethf1f5)\nprohdr = @block(prohdr, Mixer, [profd, prore], prof1f5)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Print the equations and variables in the model so far:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"print_model(m)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Note that the feed stream flow rates and compositions are fixed at default values. The recycle stream flow rates and compositions are also fixed for now; that will be changed after the rest of the model has been built. Set the values of the fixed variables to more realistic values:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"@values begin\n    ethhdr_ethfd_mass = 80_000.0\n    prohdr_profd_mass = 34_000.0\n    ethhdr_ethre_mass = 39_000.0\n    prohdr_prore_mass = 5_000.0\n    \n    ethhdr_ethre_c2h4_massfrac = 0.005\n    ethhdr_ethre_c2h6_massfrac = 0.995\n    prohdr_prore_c3h6_massfrac = 0.005\n    prohdr_prore_c3h8_massfrac = 0.96\n    prohdr_prore_mapd_massfrac = 0.035\nend","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The function set_start_values will calculate initial guesses for the free variables:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"set_start_values([ethhdr, prohdr])\nprint_vars(m)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Solve the model:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"@solve","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The solver converged immediately because set_start_values is able to calculate the values of the free variables exactly, in this case.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The mixed feed and recycle streams are fed to the cracking furnaces, which are reactors that thermally crack the feeds into a mixture called \"cracked gas.\" In this simple model the cracked gas will consist of the following components:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"comps_cg = @components h2 ch4 c2h2 c2h4 c2h6 c3h6 c3h8 mapd c4s pygas","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The ethane and propane feeds are cracked in separate furnaces. The purpose of the model is to calculate the optimal flow rates of ethane and propane feed, given constraints on furnace capacity. The cracked gas streams leaving the ethane and propane furnaces are:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(cgethf1f5, cgprof1f5) = @streams begin\n    cgethf1f5 , comps_cg, (basis=FLOW)\n    cgprof1f5 , comps_cg, (basis=FLOW)\nend","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The cracked gas streams a FLOW basis because their mass flow rates may be zero at the solution, which would make the equations based on a mass fraction formulation become singular. The furnaces are modeled with a MultiYieldReactor with two feeds: :eth and :pro.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"f1f5 = @block(f1f5, MultiYieldReactor, [ethf1f5, prof1f5], [cgethf1f5, cgprof1f5], [:eth, :pro], :furn)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The values of the fixed variables in the furnace model are:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"print_fixed(f1f5)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The values of the fixed inlet stream variables will become free after the streams are connected (see below). The rest of the fixed variables are inputs to the model that need to be set. The single-pass yields in the furnaces are:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"@values begin\n    f1f5_eth_y_h2_from_c2h6    = 0.0411\n    f1f5_eth_y_ch4_from_c2h6   = 0.05\n    f1f5_eth_y_c2h2_from_c2h6  = 0.003\n    f1f5_eth_y_c2h4_from_c2h6  = 0.495\n    f1f5_eth_y_c3h6_from_c2h6  = 0.0043\n    f1f5_eth_y_c3h8_from_c2h6  = 0.01\n    f1f5_eth_y_mapd_from_c2h6  = 0.0002\n    f1f5_eth_y_c4s_from_c2h6   = 0.03\n    f1f5_eth_y_pygas_from_c2h6 = 0.02\n    \n    f1f5_eth_y_h2_from_c2h4    = -0.009\n    f1f5_eth_y_ch4_from_c2h4   = 0.129\n    f1f5_eth_y_c2h2_from_c2h4  = 0.004\n    f1f5_eth_y_c2h6_from_c2h4  = 0.0\n    f1f5_eth_y_c3h6_from_c2h4  = 0.003\n    f1f5_eth_y_c3h8_from_c2h4  = 0.002\n    f1f5_eth_y_mapd_from_c2h4  = 0.0\n    f1f5_eth_y_c4s_from_c2h4   = 0.05\n    f1f5_eth_y_pygas_from_c2h4 = 0.15\n    \n    f1f5_pro_y_h2_from_c3h8    = 0.01\n    f1f5_pro_y_ch4_from_c3h8   = 0.21\n    f1f5_pro_y_c2h2_from_c3h8  = 0.004\n    f1f5_pro_y_c2h4_from_c3h8  = 0.35\n    f1f5_pro_y_c2h6_from_c3h8  = 0.04\n    f1f5_pro_y_c3h6_from_c3h8  = 0.16\n    f1f5_pro_y_mapd_from_c3h8  = 0.004\n    f1f5_pro_y_c4s_from_c3h8   = 0.015\n    f1f5_pro_y_pygas_from_c3h8 = 0.025\n    \n    f1f5_pro_y_h2_from_c3h6    = -0.0035\n    f1f5_pro_y_ch4_from_c3h6   = 0.15 \n    f1f5_pro_y_c2h2_from_c3h6  = 0.005 \n    f1f5_pro_y_c2h4_from_c3h6  = 0.04 \n    f1f5_pro_y_c2h6_from_c3h6  = 0.004 \n    f1f5_pro_y_c3h8_from_c3h6  = 0.0000\n    f1f5_pro_y_mapd_from_c3h6  = 0.002\n    f1f5_pro_y_c4s_from_c3h6   = 0.03\n    f1f5_pro_y_pygas_from_c3h6 = 0.15\n\n    f1f5_pro_y_c3h6_from_mapd  = 1.0\nend","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The flow rates of ethane and propane feed per furnace are:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"@values begin\n    f1f5_eth_rate = 30_000.0\n    f1f5_pro_rate = 40_000.0\nend","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Now that most of the fixed variables have been set, the ethf1f5 and prof1f5 inlet streams can be connected, which will free the inlet stream variables in the f1f5 block and copy the start values from the upstream Mixer blocks into the f1f5 block. The set_start_values function can then calculate the rest of the start values:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"connect([ethf1f5, prof1f5])\nset_start_values(f1f5)\n@solve","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The cracked gas streams leaving the furnaces are mixed together in the cracked gas header. The same pattern is used to add additional blocks to the model:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Define component groups\nCreate inlet and outlet streams\nCreate the block\nConnect the block's inlet streams to the upstream block\nConfigure variable specifications if necessary\nSet values of the fixed variables\nCall set_start_values\nSolve the model and print variables if desired","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"To keep the output as concise as possible we'll avoid solving the model repeatedly in this example. In practice, a solve is usually done after adding each new block. ","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Cracked gas header.\ncgas = @stream(cgas, comps_cg)\ncghdr = @block(cghdr, Mixer, [cgethf1f5, cgprof1f5], cgas)\nconnect([cgethf1f5, cgprof1f5])\nset_start_values(cghdr)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The cracked gas flows to the quench section, where heavy pygas is separated out as a product. In this simple model, there's only one pygas component, so we'll pretend that 30% of it is heavy pygas. The outlet stream from the quench section flows to the cracked gas compressor section, where the rest of the pygas is removed.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Quench section.\ncomps_pg = @components pygas\n(hpygas, cgcfeed) = @streams begin\n    hpygas  , comps_pg\n    cgcfeed , comps_cg\nend\nquench = @block(quench, Separator, cgas, [hpygas, cgcfeed])\n@set quench_pygas_hpygas_split = 0.3\nconnect(cgas)\n\n# Cracked gas compressor section.\ncomps_pygas  = @components  pygas\ncomps_DC2    = @components  h2 ch4 c2h2 c2h4 c2h6 c3h6 c3h8 mapd c4s\n(lpygas, cgcout) = @streams begin\n    lpygas , comps_pygas\n    cgcout , comps_DC2\nend\ncgc = @block(cgc, Separator, cgcfeed, [lpygas, cgcout])\nconnect(cgcfeed)\nset_start_values([quench, cgc])","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The cracked gas compressor section outlet stream flows to the front-end deethanizer, which splits it into C2- overhead and C3+ bottoms streams.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Front-end deethanizer.\ncomps_DC2oh = @components  h2 ch4 c2h2 c2h4 c2h6\ncomps_DC2bt = @components  c3h6 c3h8 mapd c4s\n(dc2oh, dc2bt) = @streams begin\n    dc2oh , comps_DC2oh\n    dc2bt , comps_DC2bt\nend\ndc2 = @block(dc2, Separator, cgcout, [dc2oh, dc2bt])\nconnect(cgcout)\nset_start_values(dc2)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The overhead stream from the deethanizer flows to the acetylene reactors, which convert all of the acetylene into ethylene and ethane.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Acetylene reactors.\ncomps_ARX = @components  h2 ch4 c2h4 c2h6\narxo = @stream(arxo, comps_ARX)\narx_stoic = @stoic begin    # Reaction stoichiometry\n    c2h2 + h2  => c2h4\n    c2h2 + 2h2 => c2h6\nend\n\narx_mw = Dict(:c2h2 => 26.03728,    # Molecular weights of the reacting components\n              :h2   =>  2.01588,\n              :c2h4 => 28.05316,\n              :c2h6 => 30.06904)\n\narx_conv = OrderedDict(1 => (c=:c2h2, X=0.7))   # C2H2 conversion in reaction 1.\n                                                # Don't need to specify C2H2 conversion in reaction 2, because\n                                                # C2H2 is not present in the outlet stream component list.\n                                                \narx = @block(arx, StoicReactor, dc2oh, arxo, arx_stoic, arx_mw, arx_conv)\nconnect(dc2oh)\nset_start_values(arx)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The acetylene reactor outlet stream flows to the cold train/demethanizer. The offgas, containing H2, CH4, and a small amount of C2H4, is separated out as a product.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Cold train/demethanizer.\ncomps_OG  = @components  h2 ch4 c2h4\ncomps_C2S = @components  c2h4 c2h6\n(offgas, dc1bt) = @streams begin\n    offgas , comps_OG\n    dc1bt  , comps_C2S\nend\nctdc1 = @block(ctdc1, Separator, arxo, [offgas, dc1bt])\nconnect(arxo)\n\n# The split fraction of C2H4 in the offgas starts out as a fixed variable. The offgas C2H4 mass fraction is free.\n# To calculate good start values, we have to set the value of the split fraction.\n@set ctdc1_c2h4_offgas_split = 0.001\nset_start_values(ctdc1)\n\n# Now we flip the specs, which frees the offgas C2H4 split fraction and fixes the offgas C2H4 mass fraction.\n# We need to set the offgas C2H4 mass fraction to the desired value.\n@specs(ctdc1_c2h4_offgas_split ~ ctdc1_offgas_c2h4_massfrac)\n@set ctdc1_offgas_c2h4_massfrac = 0.005\n","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The demethanizer bottoms stream flows to the C2 splitter, which splits it into an ethylene product stream and a recycle stream to the ethane header. The recycle stream is mostly ethane with a small amount of ethylene mixed in.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# C2 splitter.\nc2h4p = @stream(c2h4p, comps_C2S)\nc2s = @block(c2s, Separator, dc1bt, [c2h4p, ethre])\n\n# Since c2s_c2h4_c2h4p_split is the first split frac, it's fixed by default. But we prefer to fix\n# c2s_c2h4_ethre_split instead, so flip the specs on those two variables.\n@specs c2s_c2h4_c2h4p_split ~ c2s_c2h4_ethre_split\n\n# Assign values to the fixed split fracs and set the start values.\n@values begin\n    c2s_c2h6_c2h4p_split    = 0.001\n    c2s_c2h4_ethre_split    = 0.003\nend\nconnect([dc1bt, ethre])\nset_start_values(c2s)\n\n# Flip the specs to fix the mass fractions and free the split fracs.\n@specs begin\n    c2s_c2h4_ethre_split    ~ c2s_ethre_c2h4_massfrac\n    c2s_c2h4p_c2h6_massfrac ~ c2s_c2h6_c2h4p_split\nend\n\n# Set the values of the fixed mass fractions.\n@values begin\n    c2s_c2h4p_c2h6_massfrac = 0.0008\n    c2s_ethre_c2h4_massfrac = 0.005\nend","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The deethanizer bottoms flows to the depropanizer, which splits it into C3- overhead and C4 bottoms streams.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Depropanizer.\ncomps_DC3oh   = @components  c3h6 c3h8 mapd\ncomps_DC3bt   = @components  c4s\n(dc3oh, c4sp) = @streams begin\n    dc3oh  , comps_DC3oh\n    c4sp   , comps_DC3bt\nend\n\n# The separation is assumed to be clean, so all the split fracs are 1.\ndc3 = @block(dc3, Separator, dc2bt, [dc3oh, c4sp])\nconnect(dc2bt)\nset_start_values(dc3)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The depropanizer overhead C3- stream is fed to the C3 splitter, which produces a propylene product stream and a propane recycle stream.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# C3 splitter.\ncomps_C3Soh   = @components  c3h6 c3h8\nc3h6p = @stream(c3h6p, comps_C3Soh)\nc3s = @block(c3s, Separator, dc3oh, [c3h6p, prore])\nconnect(dc3oh)\n\n# Fix c3s_c3h8_c3h6p_split and free c3s_c3h8_prore_split, and set the fixed split fractions.\n@specs c3s_c3h8_c3h6p_split ~ c3s_c3h8_prore_split\n@values begin\n    c3s_c3h6_prore_split = 0.003\n    c3s_c3h8_c3h6p_split = 0.00017\nend\n\n# Calculate the start values.\nset_start_values(c3s)\n\n# Flip the split fracs with the mass fractions, and set the mass fractions.\n@specs begin\n    c3s_prore_c3h6_massfrac ~ c3s_c3h6_prore_split\n    c3s_c3h6p_c3h8_massfrac ~ c3s_c3h8_c3h6p_split\nend\n@set c3s_c3h6p_c3h8_massfrac = 0.0001\n@set c3s_prore_c3h6_massfrac = 0.005\n\n# Connect the propane recycle, and solve the model.\nconnect(prore)\n@solve","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Update all the start values in the model.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"set_start_values(m)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Define a set of prices and an objective function:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Prices and objective function.\nprices = Dict(\n    :ethane_feed  => 10.0,\n    :propane_feed => 15.0,\n    :c2h4_prod    => 40.0,\n    :c3h6_prod    => 30.0,\n    :c4s_prod     => 28.0,\n    :pygas_prod   => 23.0,\n    :offgas_prod  => 25.0\n    )\nmap!(p -> p/100.0, values(prices))  # Convert from cents/lb to #/lb\n\ncosts = @expression(m, m[:ethhdr_ethfd_mass]  * prices[:ethane_feed] +\n                       m[:prohdr_profd_mass]  * prices[:propane_feed])\nsales = @expression(m, m[:c2s_c2h4p_mass]     * prices[:c2h4_prod] +\n                       m[:c3s_c3h6p_mass]     * prices[:c3h6_prod] +\n                       m[:dc3_c4sp_mass]      * prices[:c4s_prod]  +\n                       m[:quench_hpygas_mass] * prices[:pygas_prod] +\n                       m[:cgc_lpygas_mass]    * prices[:pygas_prod] +\n                       m[:ctdc1_offgas_mass]  * prices[:offgas_prod])\n@objective(m, Max, sales - costs);","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Make the ethane and propane feed flow rates degrees of freedom.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"@specs begin\n    -ethhdr_ethfd_mass\n    -prohdr_profd_mass\nend\ndof = [m[:ethhdr_ethfd_mass], m[:prohdr_profd_mass]]","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Add some variable bounds.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"@bounds begin\n    0.0 < ethhdr_ethfd_mass < 2.0e5\n    0.0 < prohdr_profd_mass < 2.0e5\n    f1f5_n_furn < 5.0\n    0.0 < f1f5_pro_n_furn < 3.0\n    1.0 < f1f5_eth_n_furn\nend\nprint_bounds(m)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Solve the optimization problem.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"@solve","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Print the values of the degrees of freedom at the solution, the active bounds, and the value of the objective function.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"print_vars(dof)\nprint_active(m)\neval_obj(m)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Update the start values.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"set_start_values(m)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Lower the ethane feed price to half its previous value and solve the problem again.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"set_objective_coefficient(m, m[:ethhdr_ethfd_mass], 5.0/100.0)\n@solve","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The solver decreases the fresh propane feed flow rate to zero. ","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"print_vars(dof)\nprint_active(m)\neval_obj(m)","category":"page"},{"location":"#MassBalanceOpt.jl","page":"Introduction","title":"MassBalanceOpt.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This is a package for formulating mass balance models of chemical processes and solving them with JuMP. The user can build a model from a handful of unit operations (Mixer, Splitter, Separator,  StoicReactor, YieldReactor, MultiYieldReactor) connected by Streams and organized into Flowsheets. The package also provides functions and macros for specifying and working with the model. Familiarity with JuMP is a prerequisite for using this package.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The audience for the package is users of process simulators, particularly those that offer an equation-oriented solution mode, who want to solve optimization models of processes for which energy balances are either unneccesary or so straightforward that they can be formulated directly in JuMP. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"JuMP is a general purpose algebraic modeling language. The basic objects in a JuMP model are variables, variable bounds, constraints (referred to here as equations), objective functions, and solvers. MassBalanceOpt provides an additional layer of objects specific to process flowsheeting. Those objects are:","category":"page"},{"location":"#Streams","page":"Introduction","title":"Streams","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A Stream represents a flow of material in a process. A stream contains a total mass flow rate and either a set of mass fractions (if the StreamBasis = FRAC, the default), or component mass flow rates (if the StreamBasis = FLOW). A stream's components are specified as an OrderedSet of symbols, usually created with the @components macro. Streams flow into and out of blocks, which are sets of equations that represent mass balance operations. By themselves, streams don't create or contain variables; the blocks do that. Streams can be created with the @stream or @streams macros, or by calling the Stream constructor directly.","category":"page"},{"location":"#Blocks","page":"Introduction","title":"Blocks","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A block is a subtype of AbstractBlock. A block has inlet and outlet streams, and may have other input variables like split fractions or stoichiometric coefficients. A block contains the variables and equations that model a particular unit operation. Blocks can be created with the @block macro, or by calling the block's constructor. A block is created with some of its variables fixed to default values, so that the block is a self-contained model with the same number of equations and free variables. The inlet stream variables are initially fixed, so the blocks start out in a disconnected state. The function connect is used to connect a stream that flows out of one block and into another. This is a common practice in an equation-based process simulator.","category":"page"},{"location":"#Flowsheets","page":"Introduction","title":"Flowsheets","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A Flowsheet is a container for blocks and streams. Every model must have at least one flowsheet. Flowsheets can be created as children of an existing flowsheet, forming a tree structure. A flowsheet has a Julia symbol for a name. Flowsheet names are embedded in variable and equation names, so flowsheets provide namespaces that allow reuse of block and stream names in different flowsheets. A flowsheet created with the default constructor, fs = Flowsheet(), will have the name :index and has no parent. A child flowsheet can then be created with fs_unit1 = Flowsheet(:unit1, fs). Variable names in the :index flowsheet have no prefix; variables in the :unit1 flowsheet have the prefix unit1_ prepended to their names. Thus you can create a stream named feed in the :index flowsheet and a stream named feed in the :unit1 flowsheet without a variable name collision.","category":"page"},{"location":"#Macros-and-utility-functions","page":"Introduction","title":"Macros and utility functions","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package also supplies some macros and utility functions that make it easier to manipulate JuMP models. For example, instead of calling the JuMP function set_lower_bound to put a lower bound on a variable, you can use the macro @set (or if you want to be more explicit, @bounds, which is simply an alias for @set), e.g.,","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@set header_feed_mass < 100_000.0","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"sets the lower bound on variable header_feed_mass. You can do several assignments in one @set like this:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@set begin\n    var1 = 1.0\n    var2 > 0.0\n    1.0 < var3 < 10.0\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"See @set, @values, @bounds, @specs.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You can print the variables in a block by calling","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"print_vars(block_name)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"to get a table showing the solution value, bounds, start value, and an indication telling you if the variable is fixed or free. You can use the function","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"print_fixed(model_name)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"to print only the fixed variables in the model. See Printing and Output.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The package does not supply any functions or macros for creating or manipulating objective functions (except for a single function eval_obj).","category":"page"}]
}
